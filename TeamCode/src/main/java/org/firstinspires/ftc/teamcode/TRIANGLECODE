package org.firstinspires.ftc.teamcode;

import com.qualcomm.hardware.rev.RevHubOrientationOnRobot;
import com.qualcomm.robotcore.eventloop.opmode.Autonomous;
import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.hardware.DcMotorSimple;
import com.qualcomm.robotcore.hardware.IMU;

import org.firstinspires.ftc.robotcore.external.navigation.AngleUnit;
import org.firstinspires.ftc.robotcore.external.navigation.YawPitchRollAngles;


@Autonomous(name="Robot: Auto Triangle", group="Autonomous")
public class TRIANGLEAutoRun extends LinearOpMode {
    private DcMotor frontLeft = null;
    private DcMotor frontRight = null;
    private DcMotor backLeft = null;
    private DcMotor backRight = null;
    double speed = 0.75;
    long moveDuration = 700;// Move duration in milliseconds/ Change this number, to change the distance it travels per side
    long turnDuration = 600;// Turn duration in milliseconds

    @Override
    public void runOpMode() {
        // Initialize the hardware variables.
        frontLeft = hardwareMap.get(DcMotor.class, "Left_front");
        frontRight = hardwareMap.get(DcMotor.class, "Right_front");
        backLeft = hardwareMap.get(DcMotor.class, "Left_rear");
        backRight = hardwareMap.get(DcMotor.class, "Right_rear");
        backRight.setDirection(DcMotor.Direction.REVERSE);
        frontRight.setDirection(DcMotor.Direction.FORWARD);
        backLeft.setDirection(DcMotor.Direction.FORWARD);
        frontLeft.setDirection(DcMotor.Direction.FORWARD);

        waitForStart();

        if (opModeIsActive()) {
            for (int i = 0; i < 3; i++) {
                // Move forward
                frontLeft.setPower(speed);
                frontRight.setPower(speed);
                backLeft.setPower(speed);
                backRight.setPower(speed);
                sleep(moveDuration);

                // Stop moving forward
                frontLeft.setPower(0);
                frontRight.setPower(0);
                backLeft.setPower(0);
                backRight.setPower(0);
                sleep(500); // Short pause before turning

                // Turn 60 degrees
                frontLeft.setPower(speed);
                frontRight.setPower(-speed);
                backLeft.setPower(speed);
                backRight.setPower(-speed);
                sleep(turnDuration);

                // Stop turning
                frontLeft.setPower(0);
                frontRight.setPower(0);
                backLeft.setPower(0);
                backRight.setPower(0);
                sleep(500);
            }
        }
    }

    @Autonomous(name="Robot: Auto Square with Gyro and Distance", group="Autonomous")
    public static class SquareAutoRunGyro extends LinearOpMode {
        private DcMotor frontLeft = null;
        private DcMotor frontRight = null;
        private DcMotor backLeft = null;
        private DcMotor backRight = null;
        private IMU imu = null;

        private static final double DRIVE_POWER = 0.5; // Adjust robot speed
        private static final double TURN_POWER = 0.5; // Power during turning
        private static final int ENCODER_COUNTS_PER_REV = 1440; // Encoder counts per motor revolution
        private static final double WHEEL_DIAMETER_INCHES = 4.0; // Diameter of wheels in inches
        private static final double INCHES_PER_COUNT = (Math.PI * WHEEL_DIAMETER_INCHES) / ENCODER_COUNTS_PER_REV;
        private static final double DISTANCE_TO_TRAVEL_INCHES = 24; // Distance to travel before turning

        @Override
        public void runOpMode() {
            // Initialize hardware variables
            frontLeft = hardwareMap.get(DcMotor.class, "Left_front");
            frontRight = hardwareMap.get(DcMotor.class, "Right_front");
            backLeft = hardwareMap.get(DcMotor.class, "Left_rear");
            backRight = hardwareMap.get(DcMotor.class, "Right_rear");

            // Set motor directions
            backRight.setDirection(DcMotorSimple.Direction.REVERSE);
            frontRight.setDirection(DcMotorSimple.Direction.FORWARD);
            backLeft.setDirection(DcMotorSimple.Direction.FORWARD);
            frontLeft.setDirection(DcMotorSimple.Direction.FORWARD);

            // Initialize IMU
            RevHubOrientationOnRobot.LogoFacingDirection logoDirection = RevHubOrientationOnRobot.LogoFacingDirection.UP;
            RevHubOrientationOnRobot.UsbFacingDirection usbDirection = RevHubOrientationOnRobot.UsbFacingDirection.FORWARD;
            RevHubOrientationOnRobot orientationOnRobot = new RevHubOrientationOnRobot(logoDirection, usbDirection);

            imu = hardwareMap.get(IMU.class, "imu");
            imu.initialize(new IMU.Parameters(orientationOnRobot));

            // Wait for the game to start (driver presses PLAY)
            waitForStart();

            if (opModeIsActive()) {
                // Reset IMU heading
                imu.resetYaw();

                // Execute square motion
                for (int i = 0; i < 4; i++) {
                    driveForwardDistance(DISTANCE_TO_TRAVEL_INCHES);
                    turn90DegreesWithGyro(TURN_POWER);
                }
            }
        }

        // Drive forward a specific distance
        private void driveForwardDistance(double distanceInInches) {
            int targetCounts = (int)(distanceInInches / INCHES_PER_COUNT);
            resetEncoders();

            setMotorPowers(DRIVE_POWER);

            while (opModeIsActive() && (getAverageEncoderCounts() < targetCounts)) {
                telemetry.addData("Target Counts", targetCounts);
                telemetry.addData("Current Counts", getAverageEncoderCounts());
                telemetry.update();
            }

            stopMotors();
        }

        // Turn 90 degrees to the right actively using gyro feedback
        private void turn90DegreesWithGyro(double power) {
            // Start turning right
            setMotorPowers(power, -power);

            double targetHeading = getHeading() + 90; // Target heading after 90-degree turn
            while (opModeIsActive() && Math.abs(getHeading() - targetHeading) > 5) { // 5 degree tolerance
                telemetry.addData("Turn Target", targetHeading);
                telemetry.addData("Current Heading", getHeading());
                telemetry.update();
            }

            stopMotors();
        }

        // Stop all motors
        private void stopMotors() {
            setMotorPowers(0);
        }

        // Set power for all motors
        private void setMotorPowers(double power) {
            frontLeft.setPower(power);
            frontRight.setPower(power);
            backLeft.setPower(power);
            backRight.setPower(power);
        }

        // Set power for left and right motors separately
        private void setMotorPowers(double leftPower, double rightPower) {
            frontLeft.setPower(leftPower);
            frontRight.setPower(rightPower);
            backLeft.setPower(leftPower);
            backRight.setPower(rightPower);
        }

        // Reset motor encoders
        private void resetEncoders() {
            frontLeft.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
            frontRight.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
            backLeft.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
            backRight.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);

            frontLeft.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
            frontRight.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
            backLeft.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
            backRight.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
        }

        // Get average encoder counts from all motors
        private int getAverageEncoderCounts() {
            int frontLeftCounts = frontLeft.getCurrentPosition();
            int frontRightCounts = frontRight.getCurrentPosition();
            int backLeftCounts = backLeft.getCurrentPosition();
            int backRightCounts = backRight.getCurrentPosition();
            return (frontLeftCounts + frontRightCounts + backLeftCounts + backRightCounts) / 4;
        }

        // Read the robot's heading from the IMU
        private double getHeading() {
            YawPitchRollAngles orientation = imu.getRobotYawPitchRollAngles();
            return orientation.getYaw(AngleUnit.DEGREES);
        }
    }
}
