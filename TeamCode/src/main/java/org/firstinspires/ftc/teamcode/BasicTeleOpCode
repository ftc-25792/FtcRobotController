package org.firstinspires.ftc.teamcode;

import com.qualcomm.hardware.rev.RevHubOrientationOnRobot;
import com.qualcomm.robotcore.eventloop.opmode.OpMode;
import com.qualcomm.robotcore.eventloop.opmode.TeleOp;
import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.hardware.DcMotorSimple;
import com.qualcomm.robotcore.hardware.IMU;
import com.qualcomm.robotcore.hardware.Servo;

@TeleOp(name="BasicTeleOp", group="Linear Opmode")
public class BasicTeleOp extends OpMode {

    // Declare motors
    DcMotor motorFrontLeft;
    DcMotor motorFrontRight;
    DcMotor motorBackLeft;
    DcMotor motorBackRight;
    DcMotor armMotor;
    int armDesiredPosition;
    DcMotor viperMotor; // For the Viper slide
    IMU imu;

    // Servo variables
    Servo servo[];
    static final double INCREMENT = 0.1; // Amount to increment/decrement servo position
    static final double MAX_POS = 1.0; // Maximum servo position
    static final double MIN_POS = 0.0; // Minimum servo position
    double[] positions; // Current positions for each servo

    @Override
    public void init() {
        // Initialize motors
        motorFrontLeft = hardwareMap.get(DcMotor.class, "Left_front");
        motorFrontRight = hardwareMap.get(DcMotor.class, "Right_front");
        motorBackLeft = hardwareMap.get(DcMotor.class, "Left_rear");
        motorBackRight = hardwareMap.get(DcMotor.class, "Right_rear");
        armMotor = hardwareMap.get(DcMotor.class, "armMotor");
        armMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
        viperMotor = hardwareMap.get(DcMotor.class, "viperMotor");

        // Set motor directions (adjust as needed)
        motorBackRight.setDirection(DcMotorSimple.Direction.FORWARD);
        motorFrontRight.setDirection(DcMotorSimple.Direction.REVERSE);
        motorBackLeft.setDirection(DcMotorSimple.Direction.REVERSE);
        motorFrontLeft.setDirection(DcMotorSimple.Direction.REVERSE);

        // Initialize the IMU
        imu = hardwareMap.get(IMU.class, "imu");
        RevHubOrientationOnRobot.LogoFacingDirection logoDirection = RevHubOrientationOnRobot.LogoFacingDirection.UP;
        RevHubOrientationOnRobot.UsbFacingDirection usbDirection = RevHubOrientationOnRobot.UsbFacingDirection.BACKWARD;
        RevHubOrientationOnRobot orientationOnRobot = new RevHubOrientationOnRobot(logoDirection, usbDirection);
        imu.initialize(new IMU.Parameters(orientationOnRobot));

        // Initialize servos
        int SERVO_COUNT = 4;
        servo = new Servo[SERVO_COUNT];
        positions = new double[SERVO_COUNT]; // Array to hold positions for each servo
        for (int i = 0; i < SERVO_COUNT; i++) {
            servo[i] = hardwareMap.get(Servo.class, "servo" + (i + 1));
            positions[i] = MIN_POS; // Start all servos at minimum position
            servo[i].setPosition(positions[i]);
        }


    }

    @Override
    public void loop() {
        // Set gamepad inputs
        double leftStickX = gamepad1.left_stick_x;
        double leftStickY = gamepad1.left_stick_y;
        double rightStickX = gamepad1.right_stick_x;
        boolean triangle = gamepad1.dpad_up;
        boolean X = gamepad1.dpad_down;
        boolean Down = gamepad1.right_trigger>0.9;
        boolean Right = gamepad1.dpad_right;
        boolean Left= gamepad1.dpad_left;
        boolean retract = gamepad1.right_trigger>0.9; // Check if the trigger is pressed beyond a threshold

        boolean toggleUp = false;

        // Calculate wheel powers
        double frontLeftPower = leftStickY + leftStickX;
        double frontRightPower = leftStickY - leftStickX;
        double backLeftPower = leftStickY + rightStickX;
        double backRightPower = leftStickY - rightStickX;

        // Set motor powers
        motorFrontLeft.setPower(frontLeftPower);
        motorFrontRight.setPower(frontRightPower);
        motorBackLeft.setPower(backLeftPower);
        motorBackRight.setPower(backRightPower);

        // Control Viper slide with square button
        if (Down) {
            viperMotor.setPower(1.0);
        } else {
            viperMotor.setPower(0.0); // Stop Viper slide
        }

        if (Right) { // Increment position on A button press
            for (int i = 0; i < servo.length; i++) {
                if (positions[i] < MAX_POS) {
                    positions[i] += INCREMENT;
                    if (positions[i] > MAX_POS) {
                        positions[i] = MAX_POS; // Clamp to max
                    }
                    servo[i].setPosition(positions[i]);
                }
            }
        }

        if (Left) { // Decrement position on B button press
            for (int i = 0; i < servo.length; i++) {
                if (positions[i] > MIN_POS) {
                    positions[i] -= INCREMENT;
                    if (positions[i] < MIN_POS) {
                        positions[i] = MIN_POS; // Clamp to min
                    }
                    servo[i].setPosition(positions[i]);
                }
            }
        }

        if (retract) {
            viperMotor.setPower(0.0); // Stop Viper slide
        } else {
            viperMotor.setPower(-1.0);
        }
        // Control servo positions with buttons

        // Telemetry for debugging
        for (int i = 0; i < servo.length; i++) {
            telemetry.addData("Servo " + (i + 1) + " Position", "%5.2f", positions[i]);
        }
        telemetry.update();

        // Control arm with triangle button
        if (triangle) {
            if (!toggleUp) {
                armMotor.setPower(1.0);
                armDesiredPosition = armMotor.getCurrentPosition();
                toggleUp = true;
            } else {
                armMotor.setPower(-1.0);
                armDesiredPosition = armMotor.getCurrentPosition();
                toggleUp = false;
            }
        } else {
            armMotor.setPower(0.0);
            //To do: Add enocder logic to hold the motor in place
            // Use the SDK

            int currentPosition = armMotor.getCurrentPosition();
            if (currentPosition != armDesiredPosition) {
                armMotor.setTargetPosition(armDesiredPosition);
                armMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);

                //Controls the arm speed
                armMotor.setPower(Math.abs(0.01));
                while (armMotor.isBusy()) {
                    //telemetry.addData("Running to");
                    telemetry.addData("Currently at", " at %7d :%7d",
                            armMotor.getCurrentPosition());

                }
                // Stop all motion;
                armMotor.setPower(0);


                // Turn off RUN_TO_POSITION
                armMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);

                if (X) {
                    if (!toggleUp) {
                        armMotor.setPower(-1.0);
                        armDesiredPosition = armMotor.getCurrentPosition();
                        toggleUp = true;
                    } else {
                        armMotor.setPower(1.0);
                        armDesiredPosition = armMotor.getCurrentPosition();
                        toggleUp = false;
                    }
                } else {
                    armMotor.setPower(0.0);
                    //To do: Add enocder logic to hold the motor in place
                    // Use the SDK


                    if (currentPosition != armDesiredPosition) {
                        armMotor.setTargetPosition(armDesiredPosition);
                        armMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);

                        armMotor.setPower(Math.abs(0.01));
                        while (armMotor.isBusy()) {
                            //telemetry.addData("Running to");
                            telemetry.addData("Currently at", " at %7d :%7d",
                                    armMotor.getCurrentPosition());

                        }
                        // Stop all motion;
                        armMotor.setPower(0);


                        // Turn off RUN_TO_POSITION
                        armMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);

                /*
                // reset the timeout time and start motion.

            leftDrive.setPower(Math.abs(speed));
            rightDrive.setPower(Math.abs(speed));

            // keep looping while we are still active, and there is time left, and both motors are running.
            // Note: We use (isBusy() && isBusy()) in the loop test, which means that when EITHER motor hits
            // its target position, the motion will stop.  This is "safer" in the event that the robot will
            // always end the motion as soon as possible.
            // However, if you require that BOTH motors have finished their moves before the robot continues
            // onto the next step, use (isBusy() || isBusy()) in the loop test.
            while (opModeIsActive() &&
                   (runtime.seconds() < timeoutS) &&
                   (leftDrive.isBusy() && rightDrive.isBusy())) {

                // Display it for the driver.
                telemetry.addData("Running to",  " %7d :%7d", newLeftTarget,  newRightTarget);
                telemetry.addData("Currently at",  " at %7d :%7d",
                                            leftDrive.getCurrentPosition(), rightDrive.getCurrentPosition());
                telemetry.update();
            }

            // Stop all motion;
            leftDrive.setPower(0);
            rightDrive.setPower(0);

            // Turn off RUN_TO_POSITION
            leftDrive.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
            rightDrive.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
                 */
                    }
                }
            }
        }
    }}
