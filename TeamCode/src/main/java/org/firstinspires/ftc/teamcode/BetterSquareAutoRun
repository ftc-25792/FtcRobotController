package org.firstinspires.ftc.teamcode;

import com.qualcomm.hardware.rev.RevHubOrientationOnRobot;
import com.qualcomm.robotcore.eventloop.opmode.Autonomous;
import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.hardware.DcMotorSimple;
import com.qualcomm.robotcore.hardware.IMU;
import com.qualcomm.robotcore.util.ElapsedTime;
import com.qualcomm.robotcore.util.Range;
import org.firstinspires.ftc.robotcore.external.navigation.AngleUnit;
import org.firstinspires.ftc.robotcore.external.navigation.YawPitchRollAngles;

@Autonomous(name="Robot: Auto Square with Gyro", group="Autonomous")
public class SquareAutoRunGyro extends LinearOpMode {
    private DcMotor frontLeft = null;
    private DcMotor frontRight = null;
    private DcMotor backLeft = null;
    private DcMotor backRight = null;
    private IMU imu = null;

    double speed = 0.75; // Robot speed
    long moveDuration = 1000; // Adjust this duration based on robot's speed

    @Override
    public void runOpMode() {
        // Initialize the hardware variables.
        frontLeft = hardwareMap.get(DcMotor.class, "Left_front");
        frontRight = hardwareMap.get(DcMotor.class, "Right_front");
        backLeft = hardwareMap.get(DcMotor.class, "Left_rear");
        backRight = hardwareMap.get(DcMotor.class, "Right_rear");

        // Set motor directions
        backRight.setDirection(DcMotorSimple.Direction.REVERSE);
        frontRight.setDirection(DcMotorSimple.Direction.FORWARD);
        backLeft.setDirection(DcMotorSimple.Direction.FORWARD);
        frontLeft.setDirection(DcMotorSimple.Direction.FORWARD);

        // Initialize the IMU
        RevHubOrientationOnRobot.LogoFacingDirection logoDirection = RevHubOrientationOnRobot.LogoFacingDirection.UP;
        RevHubOrientationOnRobot.UsbFacingDirection usbDirection = RevHubOrientationOnRobot.UsbFacingDirection.FORWARD;
        RevHubOrientationOnRobot orientationOnRobot = new RevHubOrientationOnRobot(logoDirection, usbDirection);

        imu = hardwareMap.get(IMU.class, "imu");
        imu.initialize(new IMU.Parameters(orientationOnRobot));

        // Wait for the game to start (driver presses PLAY)
        waitForStart();

        if (opModeIsActive()) {
            // Reset the heading of the IMU
            imu.resetYaw();

            // Execute square motion
            for (int i = 0; i < 4; i++) {
                moveForwardWithGyro(speed, moveDuration);
                turn90DegreesWithGyro(speed);
            }
        }
    }

    // Move forward while maintaining heading using gyro
    private void moveForwardWithGyro(double power, long duration) {
        ElapsedTime timer = new ElapsedTime();
        double targetHeading = getHeading();
        while (opModeIsActive() && timer.milliseconds() < duration) {
            double currentHeading = getHeading();
            double error = targetHeading - currentHeading;
            double correction = Range.clip(error * 0.1, -0.5, 0.5); // Adjust the correction factor as needed.

            // Set motor powers with heading correction
            frontLeft.setPower(power + correction);
            frontRight.setPower(power - correction);
            backLeft.setPower(power + correction);
            backRight.setPower(power - correction);

            // Display data for telemetry
            telemetry.addData("Target Heading", targetHeading);
            telemetry.addData("Current Heading", currentHeading);
            telemetry.update();
        }
        stopMotors();
    }

    // Turn 90 degrees to the right actively using gyro feedback
    private void turn90DegreesWithGyro(double power) {
        // Start turning right
        frontLeft.setPower(power);
        frontRight.setPower(-power);
        backLeft.setPower(power);
        backRight.setPower(-power);

        double targetHeading = getHeading() + 90; // Target heading after 90-degree turn
        while (opModeIsActive() && Math.abs(getHeading() - targetHeading) > 2) { // 2 degree tolerance
            telemetry.addData("Turn Target", targetHeading);
            telemetry.addData("Current Heading", getHeading());
            telemetry.update();
        }

        stopMotors();
    }

    // Stop all motors
    private void stopMotors() {
        frontLeft.setPower(0);
        frontRight.setPower(0);
        backLeft.setPower(0);
        backRight.setPower(0);
    }

    // Read the robot's heading from the IMU
    private double getHeading() {
        YawPitchRollAngles orientation = imu.getRobotYawPitchRollAngles();
        return orientation.getYaw(AngleUnit.DEGREES);
    }
}
