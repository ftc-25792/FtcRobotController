package org.firstinspires.ftc.teamcode;

import com.qualcomm.hardware.rev.RevHubOrientationOnRobot;
import com.qualcomm.robotcore.eventloop.opmode.Autonomous;
import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.hardware.DcMotorSimple;
import com.qualcomm.robotcore.hardware.IMU;
import com.qualcomm.robotcore.hardware.Servo;
import com.qualcomm.robotcore.util.ElapsedTime;
import org.firstinspires.ftc.robotcore.external.navigation.AngleUnit;
import org.firstinspires.ftc.robotcore.external.navigation.YawPitchRollAngles;

@Autonomous(name = "KurryAutoFull", group = "Linear Opmode")
public class KurryAuto extends LinearOpMode {

    private DcMotor frontLeft, frontRight, backLeft, backRight;
    private DcMotor launcherLeft, launcherRight, intake;
    private IMU imu;
    private ElapsedTime runtime = new ElapsedTime();
    private Servo flapperRight, flapperLeft;
    private static final double DRIVE_SPEED = 0.5;
    private static final double TURN_SPEED = 0.4;
    private static final double HEADING_THRESHOLD = 2.0;
    private final double DIVIDER_LEFT = 0.15;
    private final double DIVIDER_PUSH = 0.75;

    @Override
    public void runOpMode() {

        frontLeft = hardwareMap.get(DcMotor.class, "frontLeft");
        frontRight = hardwareMap.get(DcMotor.class, "frontRight");
        backLeft = hardwareMap.get(DcMotor.class, "backLeft");
        backRight = hardwareMap.get(DcMotor.class, "backRight");
        launcherLeft = hardwareMap.get(DcMotor.class, "launcherLeft");
        launcherRight = hardwareMap.get(DcMotor.class, "launcherRight");
        intake = hardwareMap.get(DcMotor.class, "intake");
        flapperRight = hardwareMap.get(Servo.class, "servo1");
        flapperLeft = hardwareMap.get(Servo.class, "servo2");
//        divider = hardwareMap.get(Servo.class, "divider");
        imu = hardwareMap.get(IMU.class, "imu");
        IMU.Parameters imuParameters = new IMU.Parameters(
                new RevHubOrientationOnRobot(
                        RevHubOrientationOnRobot.LogoFacingDirection.UP,
                        RevHubOrientationOnRobot.UsbFacingDirection.FORWARD
                )
        );
        imu.initialize(imuParameters);

        frontRight.setDirection(DcMotor.Direction.FORWARD);
        backRight.setDirection(DcMotor.Direction.REVERSE);
        frontLeft.setDirection(DcMotor.Direction.REVERSE);
        backLeft.setDirection(DcMotor.Direction.FORWARD);
        launcherLeft.setDirection(DcMotorSimple.Direction.FORWARD);
        launcherRight.setDirection(DcMotorSimple.Direction.REVERSE);
        flapperRight.setDirection(Servo.Direction.REVERSE);
        flapperRight.setPosition(0.22);
        waitForStart();

        driveStraight(0.6,false);
        flapper();
        sleep(1500);
        strafing(0.2,false);
        
//        turn(45,false);
//        driveStraight(0.5, true);
//        driveStraight(0.5,false);
//        turn(45,true);
//        moveDivider(DIVIDER_PUSH);
//        flapper(false);
//        moveDivider(DIVIDER_PUSH);
//        flapper(false);
//        turn(45,false);
//        strafing(0.6, false);
//        driveStraight(0.5, true);
//        driveStraight(0.5,false);
//        strafing(0.6, true);
//        turn(45, true);
//        moveDivider(DIVIDER_PUSH);
//        flapper(false);
//        moveDivider(DIVIDER_PUSH);
//        flapper(false);
//        turn(45,false);
//        strafing(1.2, false);
//        driveStraight(0.5, true);
//        driveStraight(0.5,false);
//        strafing(1.2, true);
//        turn(45, true);
//        moveDivider(DIVIDER_PUSH);
//        flapper(false);
//        moveDivider(DIVIDER_PUSH);
//        flapper(false);
    }

//    private void moveDivider(double position) {
//        divider.setPosition(position);
//        sleep(300);
//        divider.setPosition(DIVIDER_LEFT);
//    }

    private void driveStraight(double distance, boolean isForward) {
        if (isForward) setMotorPower(DRIVE_SPEED);
        else setMotorPower(-DRIVE_SPEED);
        sleep((long)(distance*1000/DRIVE_SPEED));
        setMotorPower(0);
        launcherRight.setPower(0.65);
        launcherLeft.setPower(0.65);
        intake.setPower(1.0);
        sleep(500);

    }

    private void driveBackward(double distance) {
        setMotorPower(-DRIVE_SPEED);
        sleep((long)(distance*1000/DRIVE_SPEED));
        setMotorPower(0);
        launcherRight.setPower(0.65);
        launcherLeft.setPower(0.65);
        intake.setPower(1.0);
        sleep(500);
    }

    private void strafing(double distance, boolean isLeft) {
        if (isLeft) {
            frontLeft.setPower(-DRIVE_SPEED);
            frontRight.setPower(DRIVE_SPEED);
            backLeft.setPower(DRIVE_SPEED);
            backRight.setPower(-DRIVE_SPEED);
        } else {
            frontLeft.setPower(DRIVE_SPEED);
            frontRight.setPower(-DRIVE_SPEED);
            backLeft.setPower(-DRIVE_SPEED);
            backRight.setPower(DRIVE_SPEED);
        }
        sleep((long)(distance*1000/DRIVE_SPEED));
        setMotorPower(0);
        launcherRight.setPower(0.65);
        launcherLeft.setPower(0.65);
        intake.setPower(1.0);
        sleep(1000);
    }

    private void UpDiagonalStraf(double distance, boolean IsUpperLeft) {
        if (IsUpperLeft) {
            frontRight.setPower(DRIVE_SPEED);
            backLeft.setPower(DRIVE_SPEED);
        } else {
            backRight.setPower(DRIVE_SPEED);
            frontLeft.setPower(DRIVE_SPEED);
        }
        launcherRight.setPower(0.65);
        launcherLeft.setPower(0.65);
        intake.setPower(1.0);
        sleep((long)(distance*1000/DRIVE_SPEED));
        setMotorPower(0);
        sleep(500);
    }

    private void DownDiagonalStraf(double distance, boolean IsLowerLeft) {
        if (IsLowerLeft) {
            backRight.setPower(-DRIVE_SPEED);
            frontLeft.setPower(-DRIVE_SPEED);
        } else {
            frontRight.setPower(-DRIVE_SPEED);
            backLeft.setPower(-DRIVE_SPEED);
        }
        launcherRight.setPower(0.65);
        launcherLeft.setPower(0.65);
        intake.setPower(1.0);
        sleep((long)(distance*1000/DRIVE_SPEED));
        setMotorPower(0);
        sleep(500);
    }

    private void turn(double angle, boolean isLeft) {
        imu.resetYaw();
        double startAngle = getHeading();
        double targetAngle = startAngle+angle;
        while(targetAngle>=180) targetAngle-=360;
        while(targetAngle<-180) targetAngle+=360;
        if(isLeft){
            frontLeft.setPower(-TURN_SPEED);
            frontRight.setPower(-TURN_SPEED);
            backLeft.setPower(TURN_SPEED);
            backRight.setPower(TURN_SPEED);
        } else{
            frontLeft.setPower(TURN_SPEED);
            frontRight.setPower(TURN_SPEED);
            backLeft.setPower(-TURN_SPEED);
            backRight.setPower(-TURN_SPEED);
        }
        while(opModeIsActive() && !isAngleReached(targetAngle)) {
            telemetry.addData("Current Angle", getHeading());
            telemetry.addData("Target Angle", targetAngle);
            telemetry.update();
        }
        launcherRight.setPower(0.65);
        launcherLeft.setPower(0.65);
        intake.setPower(1.0);
        setMotorPower(0);
        sleep(500);
    }

    private double getHeading() {
        YawPitchRollAngles orientation = imu.getRobotYawPitchRollAngles();
        return orientation.getYaw(AngleUnit.DEGREES);
    }

    private boolean isAngleReached(double targetAngle) {
        double currentAngle = getHeading();
        while(currentAngle>=180) currentAngle-=360;
        while(currentAngle<-180) currentAngle+=360;
        return Math.abs(currentAngle-targetAngle)<HEADING_THRESHOLD;
    }

    private void setMotorPower(double power) {
        frontLeft.setPower(power);
        frontRight.setPower(power);
        backLeft.setPower(power);
        backRight.setPower(power);
        launcherRight.setPower(0.65);
        launcherLeft.setPower(0.65);
        intake.setPower(1.0);
    }

    void flapper() {
        flapperRight.setPosition(0.22);
        sleep(1000);
        flapperRight.setPosition(0.42);
        sleep(1000);
        flapperRight.setPosition(0.22);
        sleep(1000);
        flapperLeft.setPosition(0.02);
        sleep(1000);
        flapperLeft.setPosition(0.28);
        sleep(1000);
        launcherLeft.setPower(0.65);
        launcherRight.setPower(0.65);
        intake.setPower(1.0);
    }

    private void shoot(boolean IsRight) {
        if(IsRight) {
            launcherRight.setPower(0.8);
        } else{
            launcherLeft.setPower(0.8);
        }
        sleep(2500);
    }
}
